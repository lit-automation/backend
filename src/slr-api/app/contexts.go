// Code generated by goagen v1.4.1, DO NOT EDIT.
//
// API "SLR Automation": Application Contexts
//
// Command:
// $ goagen
// --design=github.com/wimspaargaren/slr-automation/src/slr-api/design
// --out=$(GOPATH)/src/github.com/wimspaargaren/slr-automation/src/slr-api
// --version=v1.4.3

package app

import (
	"context"
	"github.com/goadesign/goa"
	uuid "github.com/gofrs/uuid"
	"net/http"
	"strconv"
)

// CreateProjectContext provides the project create action context.
type CreateProjectContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *CreateProjectPayload
}

// NewCreateProjectContext parses the incoming request URL and body, performs validations and creates the
// context used by the project controller create action.
func NewCreateProjectContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateProjectContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateProjectContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// createProjectPayload is the project create action payload.
type createProjectPayload struct {
	Name         *string `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
	ScrapeState  *string `form:"scrape_state,omitempty" json:"scrape_state,omitempty" yaml:"scrape_state,omitempty" xml:"scrape_state,omitempty"`
	SearchString *string `form:"search_string,omitempty" json:"search_string,omitempty" yaml:"search_string,omitempty" xml:"search_string,omitempty"`
	Status       *int    `form:"status,omitempty" json:"status,omitempty" yaml:"status,omitempty" xml:"status,omitempty"`
}

// Publicize creates CreateProjectPayload from createProjectPayload
func (payload *createProjectPayload) Publicize() *CreateProjectPayload {
	var pub CreateProjectPayload
	if payload.Name != nil {
		pub.Name = payload.Name
	}
	if payload.ScrapeState != nil {
		pub.ScrapeState = payload.ScrapeState
	}
	if payload.SearchString != nil {
		pub.SearchString = payload.SearchString
	}
	if payload.Status != nil {
		pub.Status = payload.Status
	}
	return &pub
}

// CreateProjectPayload is the project create action payload.
type CreateProjectPayload struct {
	Name         *string `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
	ScrapeState  *string `form:"scrape_state,omitempty" json:"scrape_state,omitempty" yaml:"scrape_state,omitempty" xml:"scrape_state,omitempty"`
	SearchString *string `form:"search_string,omitempty" json:"search_string,omitempty" yaml:"search_string,omitempty" xml:"search_string,omitempty"`
	Status       *int    `form:"status,omitempty" json:"status,omitempty" yaml:"status,omitempty" xml:"status,omitempty"`
}

// OK sends a HTTP response with status code 200.
func (ctx *CreateProjectContext) OK(r *Project) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.project+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateProjectContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *CreateProjectContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// CreateFromCSVProjectContext provides the project createFromCSV action context.
type CreateFromCSVProjectContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *CreateFromCSVProjectPayload
}

// NewCreateFromCSVProjectContext parses the incoming request URL and body, performs validations and creates the
// context used by the project controller createFromCSV action.
func NewCreateFromCSVProjectContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateFromCSVProjectContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateFromCSVProjectContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// createFromCSVProjectPayload is the project createFromCSV action payload.
type createFromCSVProjectPayload struct {
	CsvContent *string `form:"csv_content,omitempty" json:"csv_content,omitempty" yaml:"csv_content,omitempty" xml:"csv_content,omitempty"`
	Name       *string `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
}

// Validate runs the validation rules defined in the design.
func (payload *createFromCSVProjectPayload) Validate() (err error) {
	if payload.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "name"))
	}
	if payload.CsvContent == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "csv_content"))
	}
	return
}

// Publicize creates CreateFromCSVProjectPayload from createFromCSVProjectPayload
func (payload *createFromCSVProjectPayload) Publicize() *CreateFromCSVProjectPayload {
	var pub CreateFromCSVProjectPayload
	if payload.CsvContent != nil {
		pub.CsvContent = *payload.CsvContent
	}
	if payload.Name != nil {
		pub.Name = *payload.Name
	}
	return &pub
}

// CreateFromCSVProjectPayload is the project createFromCSV action payload.
type CreateFromCSVProjectPayload struct {
	CsvContent string `form:"csv_content" json:"csv_content" yaml:"csv_content" xml:"csv_content"`
	Name       string `form:"name" json:"name" yaml:"name" xml:"name"`
}

// Validate runs the validation rules defined in the design.
func (payload *CreateFromCSVProjectPayload) Validate() (err error) {
	if payload.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "name"))
	}
	if payload.CsvContent == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "csv_content"))
	}
	return
}

// OK sends a HTTP response with status code 200.
func (ctx *CreateFromCSVProjectContext) OK(r *Project) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.project+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateFromCSVProjectContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *CreateFromCSVProjectContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}

// GraphProjectContext provides the project graph action context.
type GraphProjectContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ProjectID uuid.UUID
}

// NewGraphProjectContext parses the incoming request URL and body, performs validations and creates the
// context used by the project controller graph action.
func NewGraphProjectContext(ctx context.Context, r *http.Request, service *goa.Service) (*GraphProjectContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GraphProjectContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramProjectID := req.Params["projectID"]
	if len(paramProjectID) > 0 {
		rawProjectID := paramProjectID[0]
		if projectID, err2 := uuid.FromString(rawProjectID); err2 == nil {
			rctx.ProjectID = projectID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("projectID", rawProjectID, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GraphProjectContext) OK(r GraphmediaCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.graphmedia+json; type=collection")
	}
	if r == nil {
		r = GraphmediaCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GraphProjectContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// LatestProjectContext provides the project latest action context.
type LatestProjectContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewLatestProjectContext parses the incoming request URL and body, performs validations and creates the
// context used by the project controller latest action.
func NewLatestProjectContext(ctx context.Context, r *http.Request, service *goa.Service) (*LatestProjectContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := LatestProjectContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *LatestProjectContext) OK(r *Project) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.project+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *LatestProjectContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// ListProjectContext provides the project list action context.
type ListProjectContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewListProjectContext parses the incoming request URL and body, performs validations and creates the
// context used by the project controller list action.
func NewListProjectContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListProjectContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListProjectContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListProjectContext) OK(r ProjectCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.project+json; type=collection")
	}
	if r == nil {
		r = ProjectCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ListProjectContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// RemoveDuplicatesProjectContext provides the project removeDuplicates action context.
type RemoveDuplicatesProjectContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ProjectID uuid.UUID
}

// NewRemoveDuplicatesProjectContext parses the incoming request URL and body, performs validations and creates the
// context used by the project controller removeDuplicates action.
func NewRemoveDuplicatesProjectContext(ctx context.Context, r *http.Request, service *goa.Service) (*RemoveDuplicatesProjectContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RemoveDuplicatesProjectContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramProjectID := req.Params["projectID"]
	if len(paramProjectID) > 0 {
		rawProjectID := paramProjectID[0]
		if projectID, err2 := uuid.FromString(rawProjectID); err2 == nil {
			rctx.ProjectID = projectID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("projectID", rawProjectID, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *RemoveDuplicatesProjectContext) OK(r *Dupl) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.dupl+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *RemoveDuplicatesProjectContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *RemoveDuplicatesProjectContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *RemoveDuplicatesProjectContext) InternalServerError() error {
	ctx.ResponseData.WriteHeader(500)
	return nil
}

// ShowProjectContext provides the project show action context.
type ShowProjectContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ProjectID uuid.UUID
}

// NewShowProjectContext parses the incoming request URL and body, performs validations and creates the
// context used by the project controller show action.
func NewShowProjectContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowProjectContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowProjectContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramProjectID := req.Params["projectID"]
	if len(paramProjectID) > 0 {
		rawProjectID := paramProjectID[0]
		if projectID, err2 := uuid.FromString(rawProjectID); err2 == nil {
			rctx.ProjectID = projectID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("projectID", rawProjectID, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowProjectContext) OK(r *Project) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.project+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ShowProjectContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// UpdateProjectContext provides the project update action context.
type UpdateProjectContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ProjectID uuid.UUID
	Payload   *UpdateProjectPayload
}

// NewUpdateProjectContext parses the incoming request URL and body, performs validations and creates the
// context used by the project controller update action.
func NewUpdateProjectContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateProjectContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateProjectContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramProjectID := req.Params["projectID"]
	if len(paramProjectID) > 0 {
		rawProjectID := paramProjectID[0]
		if projectID, err2 := uuid.FromString(rawProjectID); err2 == nil {
			rctx.ProjectID = projectID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("projectID", rawProjectID, "uuid"))
		}
	}
	return &rctx, err
}

// updateProjectPayload is the project update action payload.
type updateProjectPayload struct {
	Name         *string `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
	ScrapeState  *string `form:"scrape_state,omitempty" json:"scrape_state,omitempty" yaml:"scrape_state,omitempty" xml:"scrape_state,omitempty"`
	SearchString *string `form:"search_string,omitempty" json:"search_string,omitempty" yaml:"search_string,omitempty" xml:"search_string,omitempty"`
	Status       *int    `form:"status,omitempty" json:"status,omitempty" yaml:"status,omitempty" xml:"status,omitempty"`
}

// Publicize creates UpdateProjectPayload from updateProjectPayload
func (payload *updateProjectPayload) Publicize() *UpdateProjectPayload {
	var pub UpdateProjectPayload
	if payload.Name != nil {
		pub.Name = payload.Name
	}
	if payload.ScrapeState != nil {
		pub.ScrapeState = payload.ScrapeState
	}
	if payload.SearchString != nil {
		pub.SearchString = payload.SearchString
	}
	if payload.Status != nil {
		pub.Status = payload.Status
	}
	return &pub
}

// UpdateProjectPayload is the project update action payload.
type UpdateProjectPayload struct {
	Name         *string `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
	ScrapeState  *string `form:"scrape_state,omitempty" json:"scrape_state,omitempty" yaml:"scrape_state,omitempty" xml:"scrape_state,omitempty"`
	SearchString *string `form:"search_string,omitempty" json:"search_string,omitempty" yaml:"search_string,omitempty" xml:"search_string,omitempty"`
	Status       *int    `form:"status,omitempty" json:"status,omitempty" yaml:"status,omitempty" xml:"status,omitempty"`
}

// OK sends a HTTP response with status code 200.
func (ctx *UpdateProjectContext) OK(r *Project) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.project+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdateProjectContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UpdateProjectContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *UpdateProjectContext) InternalServerError() error {
	ctx.ResponseData.WriteHeader(500)
	return nil
}

// CreateArticleContext provides the article create action context.
type CreateArticleContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ProjectID uuid.UUID
	Payload   *CreateArticlePayload
}

// NewCreateArticleContext parses the incoming request URL and body, performs validations and creates the
// context used by the article controller create action.
func NewCreateArticleContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateArticleContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateArticleContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramProjectID := req.Params["projectID"]
	if len(paramProjectID) > 0 {
		rawProjectID := paramProjectID[0]
		if projectID, err2 := uuid.FromString(rawProjectID); err2 == nil {
			rctx.ProjectID = projectID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("projectID", rawProjectID, "uuid"))
		}
	}
	return &rctx, err
}

// createArticlePayload is the article create action payload.
type createArticlePayload struct {
	Abstract           *string `form:"abstract,omitempty" json:"abstract,omitempty" yaml:"abstract,omitempty" xml:"abstract,omitempty"`
	Authors            *string `form:"authors,omitempty" json:"authors,omitempty" yaml:"authors,omitempty" xml:"authors,omitempty"`
	CitedAmount        *int    `form:"cited_amount,omitempty" json:"cited_amount,omitempty" yaml:"cited_amount,omitempty" xml:"cited_amount,omitempty"`
	CitedBy            *string `form:"cited_by,omitempty" json:"cited_by,omitempty" yaml:"cited_by,omitempty" xml:"cited_by,omitempty"`
	Comment            *string `form:"comment,omitempty" json:"comment,omitempty" yaml:"comment,omitempty" xml:"comment,omitempty"`
	Doi                *string `form:"doi,omitempty" json:"doi,omitempty" yaml:"doi,omitempty" xml:"doi,omitempty"`
	FullText           *string `form:"full_text,omitempty" json:"full_text,omitempty" yaml:"full_text,omitempty" xml:"full_text,omitempty"`
	GotPdf             *bool   `form:"got_pdf,omitempty" json:"got_pdf,omitempty" yaml:"got_pdf,omitempty" xml:"got_pdf,omitempty"`
	Journal            *string `form:"journal,omitempty" json:"journal,omitempty" yaml:"journal,omitempty" xml:"journal,omitempty"`
	Language           *string `form:"language,omitempty" json:"language,omitempty" yaml:"language,omitempty" xml:"language,omitempty"`
	Platform           *int    `form:"platform,omitempty" json:"platform,omitempty" yaml:"platform,omitempty" xml:"platform,omitempty"`
	Publisher          *string `form:"publisher,omitempty" json:"publisher,omitempty" yaml:"publisher,omitempty" xml:"publisher,omitempty"`
	Query              *string `form:"query,omitempty" json:"query,omitempty" yaml:"query,omitempty" xml:"query,omitempty"`
	QueryPlatform      *string `form:"query_platform,omitempty" json:"query_platform,omitempty" yaml:"query_platform,omitempty" xml:"query_platform,omitempty"`
	SearchResultNumber *int    `form:"search_result_number,omitempty" json:"search_result_number,omitempty" yaml:"search_result_number,omitempty" xml:"search_result_number,omitempty"`
	Status             *int    `form:"status,omitempty" json:"status,omitempty" yaml:"status,omitempty" xml:"status,omitempty"`
	Title              *string `form:"title,omitempty" json:"title,omitempty" yaml:"title,omitempty" xml:"title,omitempty"`
	Type               *string `form:"type,omitempty" json:"type,omitempty" yaml:"type,omitempty" xml:"type,omitempty"`
	URL                *string `form:"url,omitempty" json:"url,omitempty" yaml:"url,omitempty" xml:"url,omitempty"`
	Year               *int    `form:"year,omitempty" json:"year,omitempty" yaml:"year,omitempty" xml:"year,omitempty"`
}

// Publicize creates CreateArticlePayload from createArticlePayload
func (payload *createArticlePayload) Publicize() *CreateArticlePayload {
	var pub CreateArticlePayload
	if payload.Abstract != nil {
		pub.Abstract = payload.Abstract
	}
	if payload.Authors != nil {
		pub.Authors = payload.Authors
	}
	if payload.CitedAmount != nil {
		pub.CitedAmount = payload.CitedAmount
	}
	if payload.CitedBy != nil {
		pub.CitedBy = payload.CitedBy
	}
	if payload.Comment != nil {
		pub.Comment = payload.Comment
	}
	if payload.Doi != nil {
		pub.Doi = payload.Doi
	}
	if payload.FullText != nil {
		pub.FullText = payload.FullText
	}
	if payload.GotPdf != nil {
		pub.GotPdf = payload.GotPdf
	}
	if payload.Journal != nil {
		pub.Journal = payload.Journal
	}
	if payload.Language != nil {
		pub.Language = payload.Language
	}
	if payload.Platform != nil {
		pub.Platform = payload.Platform
	}
	if payload.Publisher != nil {
		pub.Publisher = payload.Publisher
	}
	if payload.Query != nil {
		pub.Query = payload.Query
	}
	if payload.QueryPlatform != nil {
		pub.QueryPlatform = payload.QueryPlatform
	}
	if payload.SearchResultNumber != nil {
		pub.SearchResultNumber = payload.SearchResultNumber
	}
	if payload.Status != nil {
		pub.Status = payload.Status
	}
	if payload.Title != nil {
		pub.Title = payload.Title
	}
	if payload.Type != nil {
		pub.Type = payload.Type
	}
	if payload.URL != nil {
		pub.URL = payload.URL
	}
	if payload.Year != nil {
		pub.Year = payload.Year
	}
	return &pub
}

// CreateArticlePayload is the article create action payload.
type CreateArticlePayload struct {
	Abstract           *string `form:"abstract,omitempty" json:"abstract,omitempty" yaml:"abstract,omitempty" xml:"abstract,omitempty"`
	Authors            *string `form:"authors,omitempty" json:"authors,omitempty" yaml:"authors,omitempty" xml:"authors,omitempty"`
	CitedAmount        *int    `form:"cited_amount,omitempty" json:"cited_amount,omitempty" yaml:"cited_amount,omitempty" xml:"cited_amount,omitempty"`
	CitedBy            *string `form:"cited_by,omitempty" json:"cited_by,omitempty" yaml:"cited_by,omitempty" xml:"cited_by,omitempty"`
	Comment            *string `form:"comment,omitempty" json:"comment,omitempty" yaml:"comment,omitempty" xml:"comment,omitempty"`
	Doi                *string `form:"doi,omitempty" json:"doi,omitempty" yaml:"doi,omitempty" xml:"doi,omitempty"`
	FullText           *string `form:"full_text,omitempty" json:"full_text,omitempty" yaml:"full_text,omitempty" xml:"full_text,omitempty"`
	GotPdf             *bool   `form:"got_pdf,omitempty" json:"got_pdf,omitempty" yaml:"got_pdf,omitempty" xml:"got_pdf,omitempty"`
	Journal            *string `form:"journal,omitempty" json:"journal,omitempty" yaml:"journal,omitempty" xml:"journal,omitempty"`
	Language           *string `form:"language,omitempty" json:"language,omitempty" yaml:"language,omitempty" xml:"language,omitempty"`
	Platform           *int    `form:"platform,omitempty" json:"platform,omitempty" yaml:"platform,omitempty" xml:"platform,omitempty"`
	Publisher          *string `form:"publisher,omitempty" json:"publisher,omitempty" yaml:"publisher,omitempty" xml:"publisher,omitempty"`
	Query              *string `form:"query,omitempty" json:"query,omitempty" yaml:"query,omitempty" xml:"query,omitempty"`
	QueryPlatform      *string `form:"query_platform,omitempty" json:"query_platform,omitempty" yaml:"query_platform,omitempty" xml:"query_platform,omitempty"`
	SearchResultNumber *int    `form:"search_result_number,omitempty" json:"search_result_number,omitempty" yaml:"search_result_number,omitempty" xml:"search_result_number,omitempty"`
	Status             *int    `form:"status,omitempty" json:"status,omitempty" yaml:"status,omitempty" xml:"status,omitempty"`
	Title              *string `form:"title,omitempty" json:"title,omitempty" yaml:"title,omitempty" xml:"title,omitempty"`
	Type               *string `form:"type,omitempty" json:"type,omitempty" yaml:"type,omitempty" xml:"type,omitempty"`
	URL                *string `form:"url,omitempty" json:"url,omitempty" yaml:"url,omitempty" xml:"url,omitempty"`
	Year               *int    `form:"year,omitempty" json:"year,omitempty" yaml:"year,omitempty" xml:"year,omitempty"`
}

// OK sends a HTTP response with status code 200.
func (ctx *CreateArticleContext) OK(r *Article) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.article+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateArticleContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *CreateArticleContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *CreateArticleContext) InternalServerError() error {
	ctx.ResponseData.WriteHeader(500)
	return nil
}

// DeleteArticleContext provides the article delete action context.
type DeleteArticleContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ArticleID uuid.UUID
	ProjectID uuid.UUID
}

// NewDeleteArticleContext parses the incoming request URL and body, performs validations and creates the
// context used by the article controller delete action.
func NewDeleteArticleContext(ctx context.Context, r *http.Request, service *goa.Service) (*DeleteArticleContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DeleteArticleContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramArticleID := req.Params["articleID"]
	if len(paramArticleID) > 0 {
		rawArticleID := paramArticleID[0]
		if articleID, err2 := uuid.FromString(rawArticleID); err2 == nil {
			rctx.ArticleID = articleID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("articleID", rawArticleID, "uuid"))
		}
	}
	paramProjectID := req.Params["projectID"]
	if len(paramProjectID) > 0 {
		rawProjectID := paramProjectID[0]
		if projectID, err2 := uuid.FromString(rawProjectID); err2 == nil {
			rctx.ProjectID = projectID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("projectID", rawProjectID, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *DeleteArticleContext) OK(r *Article) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.article+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *DeleteArticleContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// DownloadArticleContext provides the article download action context.
type DownloadArticleContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ProjectID uuid.UUID
}

// NewDownloadArticleContext parses the incoming request URL and body, performs validations and creates the
// context used by the article controller download action.
func NewDownloadArticleContext(ctx context.Context, r *http.Request, service *goa.Service) (*DownloadArticleContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DownloadArticleContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramProjectID := req.Params["projectID"]
	if len(paramProjectID) > 0 {
		rawProjectID := paramProjectID[0]
		if projectID, err2 := uuid.FromString(rawProjectID); err2 == nil {
			rctx.ProjectID = projectID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("projectID", rawProjectID, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *DownloadArticleContext) OK(r *Article) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.article+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *DownloadArticleContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DownloadArticleContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *DownloadArticleContext) InternalServerError() error {
	ctx.ResponseData.WriteHeader(500)
	return nil
}

// ListArticleContext provides the article list action context.
type ListArticleContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Abstract    *string
	AmountCited *int
	Doi         *string
	ProjectID   uuid.UUID
	Status      *int
	Title       *string
	Type        *string
	Year        *int
}

// NewListArticleContext parses the incoming request URL and body, performs validations and creates the
// context used by the article controller list action.
func NewListArticleContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListArticleContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListArticleContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramAbstract := req.Params["abstract"]
	if len(paramAbstract) > 0 {
		rawAbstract := paramAbstract[0]
		rctx.Abstract = &rawAbstract
	}
	paramAmountCited := req.Params["amount_cited"]
	if len(paramAmountCited) > 0 {
		rawAmountCited := paramAmountCited[0]
		if amountCited, err2 := strconv.Atoi(rawAmountCited); err2 == nil {
			tmp10 := amountCited
			tmp9 := &tmp10
			rctx.AmountCited = tmp9
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("amount_cited", rawAmountCited, "integer"))
		}
	}
	paramDoi := req.Params["doi"]
	if len(paramDoi) > 0 {
		rawDoi := paramDoi[0]
		rctx.Doi = &rawDoi
	}
	paramProjectID := req.Params["projectID"]
	if len(paramProjectID) > 0 {
		rawProjectID := paramProjectID[0]
		if projectID, err2 := uuid.FromString(rawProjectID); err2 == nil {
			rctx.ProjectID = projectID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("projectID", rawProjectID, "uuid"))
		}
	}
	paramStatus := req.Params["status"]
	if len(paramStatus) > 0 {
		rawStatus := paramStatus[0]
		if status, err2 := strconv.Atoi(rawStatus); err2 == nil {
			tmp13 := status
			tmp12 := &tmp13
			rctx.Status = tmp12
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("status", rawStatus, "integer"))
		}
	}
	paramTitle := req.Params["title"]
	if len(paramTitle) > 0 {
		rawTitle := paramTitle[0]
		rctx.Title = &rawTitle
	}
	paramType := req.Params["type"]
	if len(paramType) > 0 {
		rawType := paramType[0]
		rctx.Type = &rawType
	}
	paramYear := req.Params["year"]
	if len(paramYear) > 0 {
		rawYear := paramYear[0]
		if year, err2 := strconv.Atoi(rawYear); err2 == nil {
			tmp15 := year
			tmp14 := &tmp15
			rctx.Year = tmp14
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("year", rawYear, "integer"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListArticleContext) OK(r ArticleCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.article+json; type=collection")
	}
	if r == nil {
		r = ArticleCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ListArticleContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// SnowballArticleContext provides the article snowball action context.
type SnowballArticleContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ProjectID uuid.UUID
}

// NewSnowballArticleContext parses the incoming request URL and body, performs validations and creates the
// context used by the article controller snowball action.
func NewSnowballArticleContext(ctx context.Context, r *http.Request, service *goa.Service) (*SnowballArticleContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SnowballArticleContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramProjectID := req.Params["projectID"]
	if len(paramProjectID) > 0 {
		rawProjectID := paramProjectID[0]
		if projectID, err2 := uuid.FromString(rawProjectID); err2 == nil {
			rctx.ProjectID = projectID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("projectID", rawProjectID, "uuid"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *SnowballArticleContext) OK(r *Article) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.article+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *SnowballArticleContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// UpdateArticleContext provides the article update action context.
type UpdateArticleContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ArticleID uuid.UUID
	ProjectID uuid.UUID
	Payload   *UpdateArticlePayload
}

// NewUpdateArticleContext parses the incoming request URL and body, performs validations and creates the
// context used by the article controller update action.
func NewUpdateArticleContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateArticleContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateArticleContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramArticleID := req.Params["articleID"]
	if len(paramArticleID) > 0 {
		rawArticleID := paramArticleID[0]
		if articleID, err2 := uuid.FromString(rawArticleID); err2 == nil {
			rctx.ArticleID = articleID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("articleID", rawArticleID, "uuid"))
		}
	}
	paramProjectID := req.Params["projectID"]
	if len(paramProjectID) > 0 {
		rawProjectID := paramProjectID[0]
		if projectID, err2 := uuid.FromString(rawProjectID); err2 == nil {
			rctx.ProjectID = projectID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("projectID", rawProjectID, "uuid"))
		}
	}
	return &rctx, err
}

// updateArticlePayload is the article update action payload.
type updateArticlePayload struct {
	Abstract           *string `form:"abstract,omitempty" json:"abstract,omitempty" yaml:"abstract,omitempty" xml:"abstract,omitempty"`
	Authors            *string `form:"authors,omitempty" json:"authors,omitempty" yaml:"authors,omitempty" xml:"authors,omitempty"`
	CitedAmount        *int    `form:"cited_amount,omitempty" json:"cited_amount,omitempty" yaml:"cited_amount,omitempty" xml:"cited_amount,omitempty"`
	CitedBy            *string `form:"cited_by,omitempty" json:"cited_by,omitempty" yaml:"cited_by,omitempty" xml:"cited_by,omitempty"`
	Comment            *string `form:"comment,omitempty" json:"comment,omitempty" yaml:"comment,omitempty" xml:"comment,omitempty"`
	Doi                *string `form:"doi,omitempty" json:"doi,omitempty" yaml:"doi,omitempty" xml:"doi,omitempty"`
	FullText           *string `form:"full_text,omitempty" json:"full_text,omitempty" yaml:"full_text,omitempty" xml:"full_text,omitempty"`
	GotPdf             *bool   `form:"got_pdf,omitempty" json:"got_pdf,omitempty" yaml:"got_pdf,omitempty" xml:"got_pdf,omitempty"`
	Journal            *string `form:"journal,omitempty" json:"journal,omitempty" yaml:"journal,omitempty" xml:"journal,omitempty"`
	Language           *string `form:"language,omitempty" json:"language,omitempty" yaml:"language,omitempty" xml:"language,omitempty"`
	Platform           *int    `form:"platform,omitempty" json:"platform,omitempty" yaml:"platform,omitempty" xml:"platform,omitempty"`
	Publisher          *string `form:"publisher,omitempty" json:"publisher,omitempty" yaml:"publisher,omitempty" xml:"publisher,omitempty"`
	Query              *string `form:"query,omitempty" json:"query,omitempty" yaml:"query,omitempty" xml:"query,omitempty"`
	QueryPlatform      *string `form:"query_platform,omitempty" json:"query_platform,omitempty" yaml:"query_platform,omitempty" xml:"query_platform,omitempty"`
	SearchResultNumber *int    `form:"search_result_number,omitempty" json:"search_result_number,omitempty" yaml:"search_result_number,omitempty" xml:"search_result_number,omitempty"`
	Status             *int    `form:"status,omitempty" json:"status,omitempty" yaml:"status,omitempty" xml:"status,omitempty"`
	Title              *string `form:"title,omitempty" json:"title,omitempty" yaml:"title,omitempty" xml:"title,omitempty"`
	Type               *string `form:"type,omitempty" json:"type,omitempty" yaml:"type,omitempty" xml:"type,omitempty"`
	URL                *string `form:"url,omitempty" json:"url,omitempty" yaml:"url,omitempty" xml:"url,omitempty"`
	Year               *int    `form:"year,omitempty" json:"year,omitempty" yaml:"year,omitempty" xml:"year,omitempty"`
}

// Publicize creates UpdateArticlePayload from updateArticlePayload
func (payload *updateArticlePayload) Publicize() *UpdateArticlePayload {
	var pub UpdateArticlePayload
	if payload.Abstract != nil {
		pub.Abstract = payload.Abstract
	}
	if payload.Authors != nil {
		pub.Authors = payload.Authors
	}
	if payload.CitedAmount != nil {
		pub.CitedAmount = payload.CitedAmount
	}
	if payload.CitedBy != nil {
		pub.CitedBy = payload.CitedBy
	}
	if payload.Comment != nil {
		pub.Comment = payload.Comment
	}
	if payload.Doi != nil {
		pub.Doi = payload.Doi
	}
	if payload.FullText != nil {
		pub.FullText = payload.FullText
	}
	if payload.GotPdf != nil {
		pub.GotPdf = payload.GotPdf
	}
	if payload.Journal != nil {
		pub.Journal = payload.Journal
	}
	if payload.Language != nil {
		pub.Language = payload.Language
	}
	if payload.Platform != nil {
		pub.Platform = payload.Platform
	}
	if payload.Publisher != nil {
		pub.Publisher = payload.Publisher
	}
	if payload.Query != nil {
		pub.Query = payload.Query
	}
	if payload.QueryPlatform != nil {
		pub.QueryPlatform = payload.QueryPlatform
	}
	if payload.SearchResultNumber != nil {
		pub.SearchResultNumber = payload.SearchResultNumber
	}
	if payload.Status != nil {
		pub.Status = payload.Status
	}
	if payload.Title != nil {
		pub.Title = payload.Title
	}
	if payload.Type != nil {
		pub.Type = payload.Type
	}
	if payload.URL != nil {
		pub.URL = payload.URL
	}
	if payload.Year != nil {
		pub.Year = payload.Year
	}
	return &pub
}

// UpdateArticlePayload is the article update action payload.
type UpdateArticlePayload struct {
	Abstract           *string `form:"abstract,omitempty" json:"abstract,omitempty" yaml:"abstract,omitempty" xml:"abstract,omitempty"`
	Authors            *string `form:"authors,omitempty" json:"authors,omitempty" yaml:"authors,omitempty" xml:"authors,omitempty"`
	CitedAmount        *int    `form:"cited_amount,omitempty" json:"cited_amount,omitempty" yaml:"cited_amount,omitempty" xml:"cited_amount,omitempty"`
	CitedBy            *string `form:"cited_by,omitempty" json:"cited_by,omitempty" yaml:"cited_by,omitempty" xml:"cited_by,omitempty"`
	Comment            *string `form:"comment,omitempty" json:"comment,omitempty" yaml:"comment,omitempty" xml:"comment,omitempty"`
	Doi                *string `form:"doi,omitempty" json:"doi,omitempty" yaml:"doi,omitempty" xml:"doi,omitempty"`
	FullText           *string `form:"full_text,omitempty" json:"full_text,omitempty" yaml:"full_text,omitempty" xml:"full_text,omitempty"`
	GotPdf             *bool   `form:"got_pdf,omitempty" json:"got_pdf,omitempty" yaml:"got_pdf,omitempty" xml:"got_pdf,omitempty"`
	Journal            *string `form:"journal,omitempty" json:"journal,omitempty" yaml:"journal,omitempty" xml:"journal,omitempty"`
	Language           *string `form:"language,omitempty" json:"language,omitempty" yaml:"language,omitempty" xml:"language,omitempty"`
	Platform           *int    `form:"platform,omitempty" json:"platform,omitempty" yaml:"platform,omitempty" xml:"platform,omitempty"`
	Publisher          *string `form:"publisher,omitempty" json:"publisher,omitempty" yaml:"publisher,omitempty" xml:"publisher,omitempty"`
	Query              *string `form:"query,omitempty" json:"query,omitempty" yaml:"query,omitempty" xml:"query,omitempty"`
	QueryPlatform      *string `form:"query_platform,omitempty" json:"query_platform,omitempty" yaml:"query_platform,omitempty" xml:"query_platform,omitempty"`
	SearchResultNumber *int    `form:"search_result_number,omitempty" json:"search_result_number,omitempty" yaml:"search_result_number,omitempty" xml:"search_result_number,omitempty"`
	Status             *int    `form:"status,omitempty" json:"status,omitempty" yaml:"status,omitempty" xml:"status,omitempty"`
	Title              *string `form:"title,omitempty" json:"title,omitempty" yaml:"title,omitempty" xml:"title,omitempty"`
	Type               *string `form:"type,omitempty" json:"type,omitempty" yaml:"type,omitempty" xml:"type,omitempty"`
	URL                *string `form:"url,omitempty" json:"url,omitempty" yaml:"url,omitempty" xml:"url,omitempty"`
	Year               *int    `form:"year,omitempty" json:"year,omitempty" yaml:"year,omitempty" xml:"year,omitempty"`
}

// OK sends a HTTP response with status code 200.
func (ctx *UpdateArticleContext) OK(r *Article) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.article+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdateArticleContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UpdateArticleContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *UpdateArticleContext) InternalServerError() error {
	ctx.ResponseData.WriteHeader(500)
	return nil
}

// HealthHealthContext provides the health health action context.
type HealthHealthContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewHealthHealthContext parses the incoming request URL and body, performs validations and creates the
// context used by the health controller health action.
func NewHealthHealthContext(ctx context.Context, r *http.Request, service *goa.Service) (*HealthHealthContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := HealthHealthContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *HealthHealthContext) OK(r *Health) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.health+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *HealthHealthContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// RefreshJWTContext provides the jwt refresh action context.
type RefreshJWTContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewRefreshJWTContext parses the incoming request URL and body, performs validations and creates the
// context used by the jwt controller refresh action.
func NewRefreshJWTContext(ctx context.Context, r *http.Request, service *goa.Service) (*RefreshJWTContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := RefreshJWTContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *RefreshJWTContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// SigninJWTContext provides the jwt signin action context.
type SigninJWTContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewSigninJWTContext parses the incoming request URL and body, performs validations and creates the
// context used by the jwt controller signin action.
func NewSigninJWTContext(ctx context.Context, r *http.Request, service *goa.Service) (*SigninJWTContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SigninJWTContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *SigninJWTContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// Unauthorized sends a HTTP response with status code 401.
func (ctx *SigninJWTContext) Unauthorized() error {
	ctx.ResponseData.WriteHeader(401)
	return nil
}

// AutoScreeningContext provides the screening auto action context.
type AutoScreeningContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ProjectID  uuid.UUID
	ScreenType string
}

// NewAutoScreeningContext parses the incoming request URL and body, performs validations and creates the
// context used by the screening controller auto action.
func NewAutoScreeningContext(ctx context.Context, r *http.Request, service *goa.Service) (*AutoScreeningContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := AutoScreeningContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramProjectID := req.Params["projectID"]
	if len(paramProjectID) > 0 {
		rawProjectID := paramProjectID[0]
		if projectID, err2 := uuid.FromString(rawProjectID); err2 == nil {
			rctx.ProjectID = projectID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("projectID", rawProjectID, "uuid"))
		}
	}
	paramScreenType := req.Params["screen_type"]
	if len(paramScreenType) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("screen_type"))
	} else {
		rawScreenType := paramScreenType[0]
		rctx.ScreenType = rawScreenType
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *AutoScreeningContext) OK(r *Autoscreenabstract) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.autoscreenabstract+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *AutoScreeningContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *AutoScreeningContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *AutoScreeningContext) InternalServerError() error {
	ctx.ResponseData.WriteHeader(500)
	return nil
}

// ShowScreeningContext provides the screening show action context.
type ShowScreeningContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ArticleID  uuid.UUID
	ProjectID  uuid.UUID
	ScreenType string
}

// NewShowScreeningContext parses the incoming request URL and body, performs validations and creates the
// context used by the screening controller show action.
func NewShowScreeningContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowScreeningContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowScreeningContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramArticleID := req.Params["articleID"]
	if len(paramArticleID) > 0 {
		rawArticleID := paramArticleID[0]
		if articleID, err2 := uuid.FromString(rawArticleID); err2 == nil {
			rctx.ArticleID = articleID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("articleID", rawArticleID, "uuid"))
		}
	}
	paramProjectID := req.Params["projectID"]
	if len(paramProjectID) > 0 {
		rawProjectID := paramProjectID[0]
		if projectID, err2 := uuid.FromString(rawProjectID); err2 == nil {
			rctx.ProjectID = projectID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("projectID", rawProjectID, "uuid"))
		}
	}
	paramScreenType := req.Params["screen_type"]
	if len(paramScreenType) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("screen_type"))
	} else {
		rawScreenType := paramScreenType[0]
		rctx.ScreenType = rawScreenType
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowScreeningContext) OK(r *Articlescreening) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.articlescreening+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ShowScreeningContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ShowScreeningContext) InternalServerError() error {
	ctx.ResponseData.WriteHeader(500)
	return nil
}

// ShownextScreeningContext provides the screening shownext action context.
type ShownextScreeningContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ProjectID  uuid.UUID
	ScreenType string
}

// NewShownextScreeningContext parses the incoming request URL and body, performs validations and creates the
// context used by the screening controller shownext action.
func NewShownextScreeningContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShownextScreeningContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShownextScreeningContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramProjectID := req.Params["projectID"]
	if len(paramProjectID) > 0 {
		rawProjectID := paramProjectID[0]
		if projectID, err2 := uuid.FromString(rawProjectID); err2 == nil {
			rctx.ProjectID = projectID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("projectID", rawProjectID, "uuid"))
		}
	}
	paramScreenType := req.Params["screen_type"]
	if len(paramScreenType) > 0 {
		rawScreenType := paramScreenType[0]
		rctx.ScreenType = rawScreenType
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShownextScreeningContext) OK(r *Articlescreening) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.articlescreening+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ShownextScreeningContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *ShownextScreeningContext) InternalServerError() error {
	ctx.ResponseData.WriteHeader(500)
	return nil
}

// UpdateScreeningContext provides the screening update action context.
type UpdateScreeningContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ArticleID  uuid.UUID
	ProjectID  uuid.UUID
	ScreenType string
	Payload    *UpdateScreeningPayload
}

// NewUpdateScreeningContext parses the incoming request URL and body, performs validations and creates the
// context used by the screening controller update action.
func NewUpdateScreeningContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateScreeningContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateScreeningContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramArticleID := req.Params["articleID"]
	if len(paramArticleID) > 0 {
		rawArticleID := paramArticleID[0]
		if articleID, err2 := uuid.FromString(rawArticleID); err2 == nil {
			rctx.ArticleID = articleID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("articleID", rawArticleID, "uuid"))
		}
	}
	paramProjectID := req.Params["projectID"]
	if len(paramProjectID) > 0 {
		rawProjectID := paramProjectID[0]
		if projectID, err2 := uuid.FromString(rawProjectID); err2 == nil {
			rctx.ProjectID = projectID
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("projectID", rawProjectID, "uuid"))
		}
	}
	paramScreenType := req.Params["screen_type"]
	if len(paramScreenType) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("screen_type"))
	} else {
		rawScreenType := paramScreenType[0]
		rctx.ScreenType = rawScreenType
	}
	return &rctx, err
}

// updateScreeningPayload is the screening update action payload.
type updateScreeningPayload struct {
	Include *bool `form:"include,omitempty" json:"include,omitempty" yaml:"include,omitempty" xml:"include,omitempty"`
}

// Validate runs the validation rules defined in the design.
func (payload *updateScreeningPayload) Validate() (err error) {
	if payload.Include == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "include"))
	}
	return
}

// Publicize creates UpdateScreeningPayload from updateScreeningPayload
func (payload *updateScreeningPayload) Publicize() *UpdateScreeningPayload {
	var pub UpdateScreeningPayload
	if payload.Include != nil {
		pub.Include = *payload.Include
	}
	return &pub
}

// UpdateScreeningPayload is the screening update action payload.
type UpdateScreeningPayload struct {
	Include bool `form:"include" json:"include" yaml:"include" xml:"include"`
}

// OK sends a HTTP response with status code 200.
func (ctx *UpdateScreeningContext) OK(r *Articlescreening) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.articlescreening+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdateScreeningContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UpdateScreeningContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *UpdateScreeningContext) InternalServerError() error {
	ctx.ResponseData.WriteHeader(500)
	return nil
}

// CreateUserContext provides the user create action context.
type CreateUserContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *CreateUserPayload
}

// NewCreateUserContext parses the incoming request URL and body, performs validations and creates the
// context used by the user controller create action.
func NewCreateUserContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateUserContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateUserContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// createUserPayload is the user create action payload.
type createUserPayload struct {
	// Email of the user
	Email *string `form:"email,omitempty" json:"email,omitempty" yaml:"email,omitempty" xml:"email,omitempty"`
	// Family name of the user
	FamilyName *string `form:"family_name,omitempty" json:"family_name,omitempty" yaml:"family_name,omitempty" xml:"family_name,omitempty"`
	// First name of the user
	FirstName *string `form:"first_name,omitempty" json:"first_name,omitempty" yaml:"first_name,omitempty" xml:"first_name,omitempty"`
	// Middle name of the user
	MiddleName *string `form:"middle_name,omitempty" json:"middle_name,omitempty" yaml:"middle_name,omitempty" xml:"middle_name,omitempty"`
	Password   *string `form:"password,omitempty" json:"password,omitempty" yaml:"password,omitempty" xml:"password,omitempty"`
}

// Validate runs the validation rules defined in the design.
func (payload *createUserPayload) Validate() (err error) {
	if payload.FirstName == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "first_name"))
	}
	if payload.FamilyName == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "family_name"))
	}
	if payload.Email == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "email"))
	}
	if payload.Password == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "password"))
	}
	return
}

// Publicize creates CreateUserPayload from createUserPayload
func (payload *createUserPayload) Publicize() *CreateUserPayload {
	var pub CreateUserPayload
	if payload.Email != nil {
		pub.Email = *payload.Email
	}
	if payload.FamilyName != nil {
		pub.FamilyName = *payload.FamilyName
	}
	if payload.FirstName != nil {
		pub.FirstName = *payload.FirstName
	}
	if payload.MiddleName != nil {
		pub.MiddleName = payload.MiddleName
	}
	if payload.Password != nil {
		pub.Password = *payload.Password
	}
	return &pub
}

// CreateUserPayload is the user create action payload.
type CreateUserPayload struct {
	// Email of the user
	Email string `form:"email" json:"email" yaml:"email" xml:"email"`
	// Family name of the user
	FamilyName string `form:"family_name" json:"family_name" yaml:"family_name" xml:"family_name"`
	// First name of the user
	FirstName string `form:"first_name" json:"first_name" yaml:"first_name" xml:"first_name"`
	// Middle name of the user
	MiddleName *string `form:"middle_name,omitempty" json:"middle_name,omitempty" yaml:"middle_name,omitempty" xml:"middle_name,omitempty"`
	Password   string  `form:"password" json:"password" yaml:"password" xml:"password"`
}

// Validate runs the validation rules defined in the design.
func (payload *CreateUserPayload) Validate() (err error) {
	if payload.FirstName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "first_name"))
	}
	if payload.FamilyName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "family_name"))
	}
	if payload.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "email"))
	}
	if payload.Password == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "password"))
	}
	return
}

// OK sends a HTTP response with status code 200.
func (ctx *CreateUserContext) OK(r *User) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.user+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateUserContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// Conflict sends a HTTP response with status code 409.
func (ctx *CreateUserContext) Conflict(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 409, r)
}

// InternalServerError sends a HTTP response with status code 500.
func (ctx *CreateUserContext) InternalServerError(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 500, r)
}
